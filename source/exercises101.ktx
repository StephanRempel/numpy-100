< q1
Dog Years

Write a script, which implements the following rules:

* If a dog is one year old, it corresponds to 14 human years.
* If a dog is two years of age, it corresponds to 22 human years.
* After this every year corresponds to five human years.

< h1
hint: 

< a1
age = int(input("Dog's age: "))
# Python2:
# age = int(raw_input("Dog's age: "))
#%%
print(age)
#%%
if age <= 0:
    print("This can't be true!")
elif age == 1:
    print("about 14 years")
elif age == 2:
    print("about 22 years")
elif age > 2:
    human = 22 + (age - 2)*5
    print("in human years:", human)

< q2
Calculating Leap Years

Rules for Leap Years: 
* Years that can be divided evenly by 4 are leap year
* Exception: Century years are not leap years unless they can be evenly divided by 400. 

< h2
hint: 

< a2
year = int(input("Year? "))

if year % 4 == 0:
    if year % 100 == 0:
        if year % 400 == 0:
            leap_year = True
        else:
            leap_year = False
    else:
        leap_year = True
else:
    leap_year = False

if leap_year:
    print(str(year) + 
            ": leap year!")
else:
    print(str(year) + 
            ": not a leap year!")

< q3
Interest calculation

Write a program, which asks for the initial balance K0 and for the interest rate.
The program shall calculate the new capital K1 after one year including the interest.

Extend the program with a while-loop, so that the capital Kn after a period of n years can be calculated.

< h3
hint: 


< a3
K = float(input("Starting capital? "))
p = float(input("Interest rate? "))
n = int(input("Number of years? "))
# python2: raw_input instead of input

i = 0
while i < n:
    K +=  K * p / 100.0
    # or K *=  1 +  p / 100.0
    i += 1
    print(i)
print("Capital after " + str(n) + " ys: " + str(K))

< q4
Population growth

A country A  has a population of 40,000,000 inhabitants and its population growth rate  is 3.3 %. The country B on the other hand has a population of 70 million inhabitants but only 1.9 % as its population growth rate. 

After how many years will A's population be higher than  B's? 

< h4
hint: 


< a4
A = 4 * 10 **7
pA = 3.3
B = 7 * 10 ** 7
pB = 1.9

i = 0
while A < B:
	A *= 1 + pA/100.
	B *= 1 + pB/100.
	print('\t' + str(i))
	i += 1 
print(i)

< q5
Guessing Number Game

Write a program, which lets a human player guess a number between a number range from 1 to n. The player inputs his gues. The program informs the player, if this number is larger, smaller or equal to the secret number, i.e. the number which the program has randomly created.

< h5
hint: 


< a5
import random
n = 20
to_be_guessed = random.randint(1,n)

guess = int(input("Your guess: "))
while guess != to_be_guessed:
    if guess > to_be_guessed:
        print("Number is too large")
    elif guess < to_be_guessed:
        print("Number is too small")
    guess = int(input("Your new guess: "))
print("You got it!")
import random
n = 20
to_be_guessed = random.randint(1,n)

while True:
    guess = int(input("Your guess: "))
    if guess > to_be_guessed:
        print("Number is too large")
    elif guess < to_be_guessed:
        print("Number is too small")
    if guess == to_be_guessed:
        break
print("You got it!")

< q6
Virtual Supermarket

Create a virtual supermarket. For every article there is a price per article and a quantity, i.e. the stock .

Create shopping lists for customers. The shopping lists contain articles plus the quantity. 

The customers fill their carts, one after the other. Check if enough goods are available!

Create a receipt for each customer.

< h6
hint: 


< a6
import random

supermarket = { "milk": {"quantity": 20, "price": 1.19},
               "biscuits":  {"quantity": 32, "price": 1.45},
               "butter":  {"quantity": 20, "price": 2.29},
               "cheese":  {"quantity": 15, "price": 1.90},
               "bread":  {"quantity": 15, "price": 2.59},
               "cookies":  {"quantity": 20, "price": 4.99},
               "yogurt": {"quantity": 18, "price": 3.65},
               "apples":  {"quantity": 35, "price": 3.15},
               "oranges":  {"quantity": 40, "price": 0.99},
               "bananas": {"quantity": 23, "price": 1.29}            
              }


available_articles = list(supermarket.keys()) + ["pears", "cherries"]
print(supermarket)

max_articles_per_customer = 5 # not like a real supermarket :-)
customers = ["Frank", "Mary", "Paul", "Jennifer"]
shopping_lists = {}
for customer in customers:
    no_of_items = random.randint(1, len(available_articles))
    shopping_lists[customer] = []
    for article_name in random.sample(available_articles, no_of_items):
        quantity = random.randint(1, max_articles_per_customer)
        shopping_lists[customer].append((article_name, quantity))

# let's look at the shopping lists
for customer in customers:     
    print(customer + ":  " + str(shopping_lists[customer]))
    
# filling the carts
carts = {}
for customer in customers:
    carts[customer] = []
    for article, quantity in shopping_lists[customer]:
        if article in supermarket:
            if supermarket[article]["quantity"] < quantity:
                quantity = supermarket[article]["quantity"]
            if quantity:
                supermarket[article]["quantity"] -= quantity
                carts[customer].append((article, quantity))
for customer in customers:                            
     print(carts[customer])
            
            
print("checkout")
for customer in customers:
    print("\ncheckout for " + customer + ":")
    total_sum = 0
    for name, quantity in carts[customer]:
        unit_price = supermarket[name]["price"]
        item_sum = quantity * unit_price
        print( "{0:3d} {1:12s} {2:8.2f} {3:8.2f}".format(quantity, name, unit_price, item_sum))
        total_sum += item_sum
    print("{0:22s} {1:11.2f}".format("total_sum:", total_sum))


< q7
 English-German dictionary

 Given a simple English-German dictionary: 
> en_de = {"red" : "rot", "green" : "grün", "blue" : "blau", "yellow":"gelb"}

> print(en_de)

Print the german translations of all words in the dictionary. 

< h7
hint: 


< a7
en_de = {"red" : "rot", "green" : "grün", "blue" : "blau", "yellow":"gelb"}
print(en_de)
print(en_de["red"])
print(en_de["green"])
print(en_de["blue"])
print(en_de["yellow"])

< q8
Loop with condition

Given a list of foods

    edibles = ["ham", "spam","eggs","nuts"]
    
Print the message 

    Great, delicious <food name>
    
for all entries except "spam"

see https://www.python-course.eu/python3_for_loop.php

< h8
hint: 


< a8
edibles = ["ham", "spam","eggs","nuts"]
for food in edibles:
    if food == "spam":
        print("No more spam please!")
#        break
    print("Great, delicious " + food)
#else:
#    print("I am so glad: No spam!")
print("Finally, I finished stuffing myself")

< q9
Command Line Parameters

Write a program, which prints 'option -h found', if called with option `-h`.

For unknown options the output `unknown option` is expected.

If called without arguments, the output `arguments expected` should be printed.

Print all parameters for debugging purposes.

< h9
hint: 


< a9
import sys
print(len(sys.argv))
for i, arg in enumerate(sys.argv):
    print(i, arg)
if len(sys.argv)==1:
    print('arguments expected')
elif sys.argv[1]=='-h':
    print('option -h found')
else:
    print('unknown option')

< q10
Morse Code

Write a function `txt2morse`, which translates a text to morse code, i.e. the function returns a string with the morse code.

Write another function `morse2txt` which translates a string in Morse code into a „normal“ string. 

The Morse character are separated by spaces. Words by three spaces.
 
< h10
hint: 


< a10
char_morse = {'A':'.-', 'B':'-...', 
'C':'-.-.', 'D':'-..', 
'E':'.', 'F':'..-.', 
'G':'--.','H':'....', 
'I':'..', 'J':'.---', 
'K':'-.-', 'L':'.-..',
'M':'--', 'N':'-.', 
'O':'---', 'P':'.--.', 
'Q':'--.-', 'R':'.-.', 
'S':'...', 'T':'-', 'U':'..-', 
'V':'...-', 'W':'.--', 'X':'-..-',
'Y':'-.--', 'Z':'--..', 
'1':'.----', '2':'...--', 
'3':'...--', '4':'....-', 
'5':'.....', '6':'-....', 
'7':'--...', '8':'---..', 
'9':'----.', '0':'-----', 
',':'--..--', '.':'.-.-.-', 
'?':'..--..', ';':'-.-.-', ':':'---...', 
'/':'-..-.', '-':'-....-', '\'':'.----.',
'(':'-.--.-', ')':'-.--.-', '[':'-.--.-', 
']':'-.--.-', '{':'-.--.-', '}':'-.--.-', '_':'..--.-'}

morse_char = {}
for char in char_morse:
    morse_char[char_morse[char]] = char
    
def txt2morse(txt, alphabet):
    morse_code = ""
    for char in txt.upper():
        if char == " ":
            morse_code += "   "
        else:
            morse_code += alphabet[char] + " "
    return morse_code

def morse2txt(txt, alphabet):
    res = ""
    mwords = txt.split("   ")
    for mword in mwords:
        for mchar in mword.split():
            res += alphabet[mchar]
        res += " "
    return res

mstring = txt2morse("So what?", char_morse)
print(mstring)
print(morse2txt(mstring, morse_char))

< q11
Count Neighbors

Write a function with a 2-dimensional field and a row and column position as parameters. The field (board) is filled with 0's and 1's. The function shall return the number of neighbors of the position.

< h11
hint: 


< a11
def number_of_neighbours(board, row, col):
    """ counts the numbers of an array_element with
    the position row and column. It is assumed,
    that i,j > 0 and i,< < len(board)-1"""
    counter = 0
    for i in [row-1,row,row+1]:
        for j in [col-1,col,col+1]:
             counter += board[i][j]
    counter -= board[row][col]
    return counter

board = [ [0,0,0,0,0,0,0,0,0,0,0,0],
          [0,1,0,1,0,0,0,0,1,0,1,0],
          [0,1,0,1,0,1,0,1,0,0,0,0],
          [0,1,1,0,0,0,0,0,1,1,1,0],
          [0,0,0,1,1,0,0,0,0,0,0,0],
          [0,1,0,1,0,0,0,0,1,0,1,0],
          [0,0,0,0,0,0,0,0,0,0,0,0]]
while True:
    r = int(input("row: "))  # Python2: raw_input
    if r == 0:
        break
    c = int(input("col: "))  # Python2: raw_input
    print("neighbours: ", number_of_neighbours(board, r,c))

< q12
findnth

Write a function which calculates the position of the n-th occurence of a 
string sub in another string s. 
If  sub doesn't occur in s, -1 shall be returned.

< h12
hint: 


< a12
def findnth(s, sub, n):
    num = 0
    start = -1
    while num < n:
        start = s.find(sub, start+1)
        if start == -1: 
            break
        num += 1
    
    return start

s = "abcxyzabcjkjkjkabclkjkjlkjabcjlj"
print(findnth(s,"abc", 4))

< q13
replacenth

Write a function which replaces the n-th  occurence of a string sub by a string replacement.
  
The function shall return the changed string or the unchanged, or the original string, if replacement didn't occur in the string.

< h13
hint: 


< a13
def replacenth(source, search, replacement, n):
    pos = findnth(source, search, n)
    if pos == -1: 
        return source
    return source[:pos] + replacement + source[pos+len(search):]

s = "abcxyzabcjkjkjkabclkjkjlkjabcjlj"
print(findnth(s,"abc", 4))
print(replacenth(s,"abc","---", 4))

< q14
Arithmetic Mean

Write a function which calculates the arithmetic mean of a variable number of values.

< h14
hint: 


< a14
def mymean(*args):
    accumulator = 0
    counter = 0
    for a in args:
       accumulator += a
       counter += 1
    print('sum(args): ', sum(args))
    print('len(args): ', len(args))
    print('type(args): ', type(args))
    return accumulator/counter  # in Py3 division defaults to float div
                                # for Py2 cast to float
#%%
print(mymean(1,5.5))
print(mymean(1,5, -3))

< q15
Interest calculations with functions

Improve the script for interest calculations with functions.
	
* A function 'typed_input' should request the user input.
The function shall take the prompt as argument and
also the expected input type (e.g. int.float,string).
The function shall display the prompt, read the user input
and transform the input into the specified type.
The result of the transformation shall be returned.

* A function  'main' shall use the function 'typed_input' 
to request the initial balance and the interest rate(as float), 
the number of years (as int). The calculation of the
balance after n years shall be done in a function 'calculate'.
A function 'output' shall display the data (in and out) of
a calculation.

* Extend the function  'main' with a loop so that the inputs
for several calculations could be repeated as often as needed.
(break if 0 is given for the number of years)
	
* The inputs and the calculated results shall be stored in a list.
A function 'table_output' shall show a formatted output 
of this list 

< h15

< a15
def typed_input(prompt,ret_type):
    in_str = input(prompt)
    return ret_type(in_str)
prompt_kap = "Initial capital? "
prompt_interest = "Interes trate? "
prompt_years = "Number of years? "    

def main():
    res_lst = []
    while True:
        years = typed_input(prompt_years,int)
        if years == 0:
            break
        kap = typed_input(prompt_kap,float)
        interest = typed_input(prompt_interest,float)
        res = calculate(kap, interest, years)
        res_lst.append((kap, interest, years,res)) #interest per line questionable
        output(kap, interest, years, res)
    table_output(res_lst)   

def calculate(kap, interest, years):
    res = kap * (1+interest/100)**years
    return res

fmt = '%10.2f %7.2f %4d %15.2f'

def output(kap, interest, years, res):
    print(fmt%(kap, interest, years, res))
    return   

def table_output(res_lst):
    for i in res_lst:
        print(fmt%i)
    return        

if __name__ == '__main__':
    main()
    

< q16
* and zip

Given the following list:
    my_list = [('a', 232), 
           ('b', 343), 
           ('c', 543), 
           ('d', 23)]

How can you transform this list by using the *-operator and the zip function into the following format
    [('a', 'b', 'c', 'd'), 
      (232, 343, 543, 23)]           

< h16
hint: 


< a16
my_list = [('a', 232), ('b', 343), ('c', 543), ('d', 23)]
list(zip(*my_list))

< q17
PYTHONPATH

Create a folder `lib` in your HOME directory.

Move the file `fibonacci.py` in this directory.

What happens now after the instruction `import fibonacci`? Can you call `fibonacci.fib(10)`?

Set or extend the environment variable PYTHONPATH and check again.


< h17
hint: 


< a17

< q18
Interest rate calculation modularized

Refactor  the script for interest rate calculation into
a module 'interest_rates_fu_mod' with the functions
' typed_input, calculate, table_output' and into a main script 
'interest_rates_fu_import.py', which imports the module 
'interest_rates_fu_mod'.

< h18

< a18
# interest_rates_fu_import.py
from interest_rates_fu_mod import  typed_input, calculate, table_output

def main():
    res_list=[]
    while True:
        kapital = typed_input("Initial capital? ",float)
        zins = typed_input("Interest rate? ",float)
        laufzeit = typed_input("Years? ",int)
        if laufzeit == 0:
            break
        endkapital = calculate(kapital,zins,laufzeit)
        res_list.append((kapital,zins,laufzeit,endkapital))
    table_output(res_list)

main()    

# interest_rates_fu_mod
def typed_input(prompt,ret_type):
    in_str = input(prompt)
    return ret_type(in_str)
prompt_kap = "Initial capital? "
prompt_interest = "Interes trate? "
prompt_years = "Number of years? "    

def calculate(kap, interest, years):
    res = kap * (1+interest/100)**years
    return res

fmt = '%10.2f %7.2f %4d %15.2f'

def output(kap, interest, years, res):
    print(fmt%(kap, interest, years, res))
    return   

def table_output(res_lst):
    for i in res_lst:
        print(fmt%i)
    return        

< q19
Checker board (algebraic notation)

The fields of a checker board (8 x 8) are denoted with row numbers (1,..., 8), and the columns `a`to `h`.

Write a list comprehension to produce a list of all field names.

< h19
hint: 


< a19
board = [j+str(i) for i in range(1,9) for j in 'abcdefgh']
board

< q20
Dictionary reversed

Write a list comprehension which inverses a given dictionary, i.e.
the values will be keys and the keys will be turned into values.  
    di = {'DE':'Deutschland','FR':'Frankreich'}

< h20
hint: 


< a20
di = {'DE':'Deutschland','FR':'Frankreich'}
inv = dict((di[i],i) for i in di)
inv

< q21
letter_frequency

Write a function, which determines the frequency of letters of a text.

A sorted (frequency) list with the letters and their frequency shall be returned.

Special characters and digits shouldn't be counted.
    s = "Monty Python"
    x = letter_frequency(s)
    print(x)

< h21
hint: 


< a21
def letter_frequency(s):
    frequency_dict = {}
    for char in s.lower():
        if char.isalpha():
            if char in frequency_dict:
                frequency_dict[char] += 1
            else:
                frequency_dict[char] = 1
    #f =  frequency_dict.items()      # Python2
    f =  list(frequency_dict.items()) # Python3
    f.sort(key = lambda x: (-x[1], x[0]))
    return f
s = "Monty Python"
x = letter_frequency(s)
print(x)

< q22
Factorial Function

Write a funktion, which calculates the factorial (n!) of a number n.

< h22
hint: 


< a22
def fak(n):
    if n == 1:
        return 1
    if n>1:
        return n*fak(n-1)
    
print(fak(4))

< q23
Birthday Factorial

Write a function, which calculates for a positive interger n the smallest k such that:

    str(n) in str(fak(k))

Write a function factorial_birthday, which calculates for a birthday d (given as ttmm) the smallest k such that:

    str(d) in str(fak(k)) 



For July 12th (1207) e.g. this is 71.
Which birthday has the smalles k, which the largest?

< h23
hint: 


< a23
from math import factorial

days_in_month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

def n_in_factorial_k(n):
    n = str(n)
    k = 0
    while True:
        if n in str(factorial(k)):
            return k
        k += 1

factorial_birthdays = []
for month in range(0, 12):
    for day in range(1, days_in_month[month]+1):
        birthday = "{:02d}{:02d}".format(day, month+1)
        factorial_birthdays.append((birthday, 		
											n_in_factorial_k(birthday)))      
print(sorted(factorial_birthdays, key=lambda x: (x[1], x[0])))
print('-'*30)
print(sorted(factorial_birthdays))

< q24
nfind recursiv

Write a recursive function, which finds the position of the n-th occurence of a string in a given string. If not found -1 should be returned.0

< h24
hint: 


< a24
def nfind(haystack, needle, n, pos=0):
    pos = haystack.find(needle, pos)
    if n == 1 or pos == -1:
        return pos
    else:
        return nfind(haystack, needle, n-1, pos+1)


for i in range(7):
    print(i,nfind("abcjjjabcooiabckkabc", "c", i))

< q25
Flatten  a nested List or Tuple

Use extend() and append() in a new function flatten(),which transforms a nested list (or tuple) into a flat one.
type() is also needed.

    >>>flatten([(1,2), "Python", ["a",[1,7]], 1, 1.3])
    [1, 2, 'Python', 'a', 1,7,1, 1.3]
    
    
< h25
hint: 


< a25
def flatten(x):

  result = []
  for el in x:
    # alternatively:
    # if isinstance(el, (list, tuple)):
    if type(el)==list or type(el)==tuple:
      result.extend(flatten(el))
    else:
      result.append(el)
  return result
  
print(flatten([(1, 2), "Python", ["a", [1,7]], 1, 1.3]))


< q26
Decorator, which counts function calls

Write a Decorator, which counts how often a function is called.

< h26
hint:


< a26
def call_counter(func):
    def helper(*args, **kwargs):
        helper.calls += 1
        return func(*args, **kwargs)
    helper.calls = 0
    helper.__name__= func.__name__

    return helper

@call_counter
def succ(x):
    return x + 1

print(succ.calls)

s = 0
for i in range(10):
    s += succ(i)
    
print(succ.calls)

< q27
File Read and Analysis

Write a program, which reads the file `bundeslaender.txt` and finds and outputs all the lands, whose area is less than 10,000 square kilo meter.

< h27
hint: 


< a27
with open("data/bundeslaender.txt", encoding="ISO-8859-1") as fh:
    #first line contains no data:
    fh.readline()
    max_size = 10000
    small_lands = []
    for line in fh:
        land, size_of_land, *rem = line.split()
        size_of_land = float(size_of_land)
        if size_of_land < max_size:
            small_lands.append(land)
    print(small_lands)

< q28
Text File from the Web 

Write a program, which directly reads in the file bundeslaender.txt from the internet location (https://www.python-course.eu/material/texts/bundeslaender.txt) and creates a new file with the following format:
„land area population  population per square km“ 

< h28
hint: 


< a28
import urllib.request
url = "https://www.python-course.eu/material/texts/bundeslaender.txt"
with urllib.request.urlopen(url) as fh:
    with open("bundeslaender.txt", "w") as fhw:
        fh.readline()
        for line in fh:
            line = line.decode("iso8859-1")   #  "utf-8" 
            land, area, male, female = line.split()
            population = int(male) + int(female)
            area_sq_km = population / float(area) * 1000
            output = land + " " + str(area)
            output += " " + str(population) + " " + str(area_sq_km)
            fhw.write( output + "\n" )

< q29
Hacker Poll

The file „hacker_poll.txt“ contains the results of a poll with the question “What’s your favorite programming language?”
(started 2012, latest update October 2014)

Please read in the file and print out the top ten values.

< h29
No hints provided...


< a29
data = []
fh = open("data/hacker_poll.txt")
for line in fh:
    language, votes = line.strip().rsplit(None, 1)
    data.append((language, int(votes)))

data.sort(key=lambda x: (x[1], x[0]), reverse = True)

top10 = data[:10]
print(top10)

< q30
Word Frequency

Write a function which counts the frequency of an arbitrary word in a text string or in a file.

< h30
No hints provided...


< a30
import re
from collections import Counter

def word_freq(txt):
    word_dict = {}
    list_of_words = re.findall(r"\b\w+\b", txt)
    for word in list_of_words:
        if word in word_dict:
            word_dict[word] += 1
        else:
            word_dict[word] = 1           
    items = list(word_dict.items())
    items.sort(key = lambda x: x[1], reverse=True)
    return items

def word_freq2(txt):
    word_dict = Counter()
    list_of_words = re.findall(r"\b\w+\b", txt)
    for word in list_of_words:
        word_dict[word] += 1
    return word_dict.most_common()

def word_freq3(txt):
    return Counter(re.findall(r"\b\w+\b", txt)).most_common()


fobj = open("data/1984.txt")
text = fobj.read()
fobj.close()
x = word_freq2(text)
print(x[:40])
x = word_freq3(text)
print(x[:40])
y = word_freq(text)
print(y)

< q31
Fibonacci Generator

Write a generator which generates the fibonacci numbers.

As a reminder:  

    F(n) = F(n-1) + F(n-2), 
    where F(0)=0 and F(1)=1

< h31
hint: 


< a31
def fibonacci():
    """Ein Fibonacci-Zahlen-Generator"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

f = fibonacci()
counter = 0
for x in f:
    print(x)
    counter += 1
    if (counter > 10):
        break 

< q32
Random Generator

Write a generator which returns a stream of zeros and ones: 

    1 with a probability of p and
    0 with a probability of (1 - p)

< h32
hint: 


< a32
import random

def random_ones_and_zeros():
    p = random.random()
    while True:
        x = random.random()
        message = yield 1 if x < p else 0
        if message != None:
            p = message
        
x = random_ones_and_zeros()
next(x)  # not interested in the return value
for p in [0.2, 0.8]:
    x.send(p)
    print("\nprobabiliy: " + str(p))    
    for i in range(15):
        print(next(x), end=" ")

< q33
Generator "trange"

Write a generator "trange", which generates a sequence of time tuples from start to stop incremented by step. 
A time tuple is a 3-tuple of integers: (hours, minutes, seconds) 

Example: 
    for time in trange((10, 10, 10), (13, 50, 15), (0, 15, 12) ):
        print(time)

will return
    (10, 10, 10)
    (10, 25, 22)
    (10, 40, 34)
    (10, 55, 46)
    (11, 10, 58)
    (11, 26, 10)

< h33
hint: 


< a33
def trange(start, stop, step):
    """ 
    trange(stop) -> time as a 3-tuple (hours, minutes, seconds)
    trange(start, stop[, step]) -> time tuple

    start: time tuple (hours, minutes, seconds)
    stop: time tuple
    step: time tuple

    returns a sequence of time tuples from start to stop
    incremented by step
    
    The generator can be rest by sending a new "start" value.
    """        

    current = list(start)
    while current < list(stop):
        new_start = yield tuple(current)
        if new_start != None:
            current = list(new_start)
            continue
        seconds = step[2] + current[2]
        min_borrow = 0
        hours_borrow = 0
        if seconds < 60:
            current[2] = seconds
        else:
            current[2] = seconds - 60
            min_borrow = 1
        minutes = step[1] + current[1] + min_borrow
        if minutes < 60:
            current[1] = minutes 
        else:
            current[1] = minutes - 60
            hours_borrow = 1
        hours = step[0] + current[0] + hours_borrow
        if hours < 24:
            current[0] = hours 
        else:
            current[0] = hours -24
            
for time in trange((10, 10, 10), (13, 50, 15), (0, 15, 12) ):
        print(time)           

< q34
Which number comes next?

Which number comes next?

    6, 8, 20, 22, 25, …

Exactly: 74, 97, …





Secret Number: 42

Number of iterations:

    46583

< h34
hint: 


< a34
from random import randint, seed

def random_ascending_lists(length, value_range=(1,100), secret_key = 0):
    seed(secret_key)
    counter = 0
    while True:
        seq = [randint(*value_range) for _ in range(length)]
        counter += 1
        if seq == sorted(seq):   
            new_secret_key = (yield (counter, secret_key, seq))
            if new_secret_key:
                secret_key = new_secret_key
                seed(secret_key)

numbers = 7
range_of_values = (1, 100)
alists = random_ascending_lists(numbers, range_of_values, 42) 
for i in range(10):
    print(next(alists))

< q35
Generator of the first ascending sequence

Change the previous Generator so that it increments seed values, beginning with a start value „secret_key = 0“. The generator has to yield an ascending list with “length” values for every (incremented) „secret_key“.

In other words: We calculate the first sequence of “length” numbers, which are ascending.

We get:

    (6847, [4, 12, 40, 65, 68, 74, 76])
    (7084, [31, 36, 51, 62, 74, 88, 90])
    (8222, [2, 15, 24, 83, 86, 92, 97])
    (8251, [4, 22, 37, 38, 40, 54, 62])
    (14752, [1, 26, 34, 40, 58, 79, 83])
    (14987, [37, 46, 57, 62, 70, 78, 84])
    (24601, [6, 11, 64, 67, 76, 95, 99])
    (31316, [15, 32, 57, 68, 86, 89, 98])
    (33586, [41, 57, 75, 89, 89, 97, 99])
    (37673, [17, 22, 34, 54, 59, 68, 83]) 

< h35
hint: 


< a35
from random import randint, seed
def random_ascending_lists(length, value_range=(1,100), secret_key = 0):
    seed(secret_key)
    counter = 0
    while True:
        seq = [randint(*value_range) for _ in range(length)]
        counter += 1
        if seq == sorted(seq):   
            new_secret_key = (yield (counter, secret_key, seq))
            if new_secret_key:
                secret_key = new_secret_key
                seed(secret_key)
                
def random_ascending_lists2(length, value_range=(1,100), secret_key = 0):
    while True:
        seed(secret_key)
        seq = [randint(*value_range) for _ in range(length)]
        secret_key += 1
        if seq == sorted(seq):   
            new_secret_key = (yield (secret_key, seq))
            if new_secret_key:
                secret_key = new_secret_key
                seed(secret_key)


range_of_values = (1, 100)
#alists = random_ascending_lists(7, range_of_values, 42) 
alists = random_ascending_lists2(7, range_of_values) 
for i in range(10):
    print(next(alists))

< q36
Generator implementing the chain-Method

Write a generator, which is similar to the chain method:

< h36
hint: 


< a36
def chain(*iterables):
    """ This generator is equivalent 
        to the chain
        method of iterables  """
    for iterable in iterables:
        for element in iterable:
            yield element

names1 = ["Pete", "Tom"]
names2 = ["Tom", "Oscar"]        
c = chain(names1, names2)
for el in c:
    print(el)

< q37
Generator equivalent to itertools.cycle

Write a generator, that is equivalent to itertools.cycle. 

< h37
hint: 


< a37
def cycle(iterable):
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element
        
numbers = cycle("abcde")
for _ in range(12):
    print(next(numbers), end=", ")

< q38
Exception handling in a loop

Try to print the contents of the files (some are not existing)

    'data/unbekannt.txt',
    'data/unbenannt.txt',
    'data/ignored.txt',
    
< h38
hint: 


< a38
import sys
file_list=[
    'data/unbekannt.txt',
    'data/unbenannt.txt',
    'data/ignored.txt',
]
for fn in file_list:
    fh=None
    try:
        fh=open(fn)
    except :
        (type, value, traceback) = sys.exc_info()
        print("Type: ", type)
        print("Value: ", value)
        print("traceback: ", traceback)
        print('Failed to open '+fn+' for reading')
        print('-'*30)
        continue
    contents=fh.read()
    print(contents)
    fh.close()

< q39
Improve the script for interest rate calculation
with exception handling/exception generation.

'typed_input' should contain a loop with break ONLY 
of input conversion was OK

The function 'calculate' shall raise an exception, 
if initial capital <= 0 or number of years < 0.

Possible exceptions shall be handled:
 in 'typed_input' (invalid type argument, just int, float or str allowed)
 in 'main' (exceptions in calls of  'typed_input' or 'calculate')


< h39

< a39
import sys

def typed_input(prompt,ret_type):
    allowed_types=[int,float,str]
    if ret_type not in allowed_types:
        raise Exception('type not allowed, seen: %s, allowed are: %s' \
                        % (str(ret_type),str(allowed_types)))
    while True:
        in_str = input(prompt)
        try:
            res = ret_type(in_str)
            break
        except:
            print('typed_input failed')
    return res

def main():
    prompt_years="Enter non-negative years (0 for end)"
    prompt_kap = "Initial capital? "
    prompt_interest = "Interest rate? "

    try:
        years = typed_input(prompt_years,int)
    except Exception as err:
        print(err)
        sys.exit(1)
    except Exception as err:
        print(err)
        sys.exit(1)
    try:
        kap = typed_input(prompt_kap,float)
    except Exception as err:
        print(err)
        sys.exit(1)
    try:
        interest = typed_input(prompt_interest,float)
    except Exception as err:
        print(err)
        sys.exit(1)
    try:
        res = calculate(kap, interest, years)
    except Exception as err:
        print(err)
        sys.exit(1)
    print(output(kap, interest, years, res))


def main1():
    typed_input_exc_msg = "typed_input call failed" 
    calculate_exc_msg = "calculate call failed"
    prompt_years="Enter non-negative years (0 for end)"
    prompt_kap = "Initial capital? "
    prompt_interest = "Interest rate? "

    res_lst = []
    while True:
        try:
            years = typed_input(prompt_years,int)
        except:
            print(typed_input_exc_msg)
            continue
        if years == 0:
            break
        try:    
            kap = typed_input(prompt_kap,float)
        except:
            print(typed_input_exc_msg)
            continue
        try:
            interest = typed_input(prompt_interest,float)
        except:
            print(typed_input_exc_msg)
            continue
        try:
            res = calculate(kap, interest, years)
        except:
            print(calculate_exc_msg)
            continue
        res_lst.append((kap, interest, years,res)) #interest per line questionable
        output(kap, interest, years, res)
    table_output(res_lst)   

def calculate(kap, interest, years):
    negativ_value_msg = "Negative values are not allowed"
    if kap < 0 or years < 0:
        raise Exception(negativ_value_msg)
    res = kap * (1+interest/100)**years
    return res

def output(kap, interest, years, res):
    fmt = '%10.2f %7.2f %4d %15.2f'
    return fmt%(kap, interest, years, res)
    
def table_output(res_lst):
    fmt = '%10.2f %7.2f %4d %15.2f'
    for i in res_lst:
        kap, interest, years, res = i #unpack tuple
        print(fmt%(kap, interest, years, res))
    return        

if __name__ == '__main__':
    main()
#    main1()


< q40
HTML-Tags with Context Manager


Create a context manager `tag` with one argument, which surrounds the  `print` output with the argument (as usual for HTML tags), e.g.

    <h1>
    My string!
    </h1>

< h40
hint: 


< a40
from contextlib import contextmanager

@contextmanager
def tag(name):
    print("<%s>" % name)
    yield
    print("</%s>" % name)


with tag("h1"):
    print("My string!")

< q41
Palindromic Square Numbers

Write a function which creates
a list of the palindromic square
numbers less than a 100
billions.

Find the only number inside of this list which has an even number of digits.

Think of a way to test the result with the doctest module, knowing that 1, 4, 9, 121, 484, 676, 10201 are amongst those numbers.

< h41
hint: 


< a41
import doctest

def palindromic_squares(n = 100000000):
    """ 
    creates a list of all the palindromical 
    square numbers less than n

    >>> {1, 4, 9, 121, 484, 676, 10201} <= set(palindromic_squares(1000000000000))
    True
    """

    counter = 1
    squared = 1
    palindrome_list = []
    while squared < n:
        s = str(squared)
        if s == s[::-1]:
            palindrome_list.append(squared)
        counter += 1
        squared = counter * counter

    return palindrome_list

def find_even_len_palindromes(plist):
    """
    returns a list of all the pallindromes of
    plist, which have an even number of digits

    >>> find_even_len_palindromes(palindromic_squares(1000000000)) == [698896]
    True
    >>> 
   
    """
    even_len_list = []
    for i in plist:
        if not len(str(i)) % 2:
             even_len_list	.append(i)
    return even_len_list  


if __name__ == "__main__": 
    doctest.testmod()

< q42
Testing of interest rates calculation

Write `pytest` tests for the modularized interest rates calculation

< h42

< a42
#TODO

< q43
Robot Class with „build_year“

Extend the robot class with an attribute „build_year“ incl. Getter and Setter.
    class Robot:
 
        def __init__(self, name=None):
            self.name = name   
            
        def say_hi(self):
            Pass  # code as in previous example
                
        def set_name(self, name):
            self.name = name
            
        def get_name(self):
            return self.name

< h43
hint: 


< a43
class Robot:
 
    def __init__(self, name=None, build_year=None):
        self.name = name 
        self.build_year=build_year
        
    def say_hi(self):
        Pass  # code as in previous example
            
    def set_name(self, name):
        self.name = name
        
    def get_name(self):
        return self.name    
    def set_build_year(self, by):
        self.build_year = by
        
    def get_build_year(self):
        return self.build_year    
    

x = Robot("Henry", 2008)
y = Robot()
y.set_name(x.get_name())
print(x.get_name(), x.get_build_year())

< q44
Robot Class with private Attributes

Implement a new version of the Robot class with private attributes „name“ and „build_year“ and corresponding Getters and Setters!

< h44
hint: 


< a44
class Robot:
 
    def __init__(self, name="None", build_year=2000):
        self.__name = name
        self.__build_year = build_year 
        
    def say_hi(self):
        if self.__name:
            print("Hi, I am " + self.__name)
        else:
            print("Sorry, I am nameless")
                 
    def set_name(self, name):
        self.__name = name
    def get_name(self):
        return self.__name
    
    def set_build_year(self, build_year):
        self.__build_year = build_year
    def get_build_year(self):
        return self.__build_year

< q45
Robot Class with Properties

Rewrite the Robot class with properties.

< h45
hint: 


< a45
class Robot:
 
    def __init__(self, name="None", build_year=2000):
        self.name = name
        self.build_year = build_year 
      
    @property   
    def name(self):
        return self.__name              
    @name.setter
    def name(self, name):
        self.__name = "Marvin" if name == "Henry" else name

    @property
    def build_year(self):
        return self.__build_year
    @build_year.setter
    def build_year(self, by):
        self.__build_year = 2000 if by < 2000 else by

< q46
Clock Class

Write a class 
clock for a digital clock.

It should implement the following methods:

    set(hours, minutes, seconds = 59);
    tick();


The method tick() should “tick” for a second, i.e. the time should be advanced by one second:

    11:59:59 → 12:00:00
    
< h46
hint: 


< a46
class Clock(object):

    def __init__(self,hours=0, minutes=0, seconds=0):
        self._hours = hours     # protected, needed in ClockCalendar
        self.__minutes = minutes
        self.__seconds = seconds

    def tick(self):
        """ Time will be advanced by one second """
        if self.__seconds == 59:
            self.__seconds = 0
            if self.__minutes == 59:
                self.__minutes = 0
                self._hours = 0 if self._hours==23  \
                                else self._hours + 1
            else:
                self.__minutes += 1
        else:
            self.__seconds += 1
    def set(self,hours, minutes, seconds=0):
        self._hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def __str__(self):
        return "%02d:%02d:%02d" % (self._hours, 
                                   self.__minutes, 
                                   self.__seconds)

if __name__ == "__main__":
    x = Clock(23, 59, 30)
    print(x)
    for i in range(31):
        x.tick()
    print(x)            

< q47
Fraction Class

Write a class for Fractional Arithmetic, implementing addition, subtraction, multiplication and division.  The results of the arithmetic operations should be a fraction which can't be reduced.

< h47
hint: 


< a47
class Fraction(object):
    def __init__(self,z,n):
        self.__num = z
        self.__den = n
        self.reduce()

    def __str__(self):
        return str(self.__num)+'/'+str(self.__den)

    @staticmethod
    def gcd(a,b):
        while b != 0:
            a,b = b,a%b
        return a

    def reduce(self):
        g = Fraction.gcd(self.__num, self.__den)
        self.__num = self.__num // g
        self.__den = self.__den // g

    def __mul__(self,other):
        p = Fraction(self.__num * other.__num,
                     self.__den * other.__den)
        p.reduce()
        return p
    # in Python 2: __div__
    def __truediv__(self,other):
        p = Fraction(self.__num * other.__den,
                  self.__den * other.__num)
        p.reduce()
        return p

    def __add__(self,other):
        s = Fraction(self.__num*other.__den + other.__num * self.__den,
                     self.__den*other.__den)
        s.reduce()
        return s

    def __sub__(self,other):
        s = Fraction(self.__num*other.__den - other.__num * self.__den,
                     self.__den * other.__den)
        s.reduce()
        return s

    def __eq__(self, other):
        return self.__num * other.__den == other.__num * self.__den
    def __ne__(self, other):
        return not self.__eq__(other)  
    def __gt__(self, other):
        return self.__num * other.__den > other.__num * self.__den
    def __ge__(self, other):
        return self.__num * other.__den >= other.__num * self.__den
    def __lt__(self, other):
        return self.__num * other.__den < other.__num * self.__den
    def __le__(self, other):
        return self.__num * other.__den <= other.__num * self.__den

if __name__ == "__main__":
    x = Fraction(2, 6)
    y = Fraction(3, 14)
    print(x * y)
    print(x / y)
    print(x + y)
    print(x - y)
    if x < y:
        print("x < y")
    else:
        print("x >= y")
    print(x)    

< q48

< h48
hint: 


< a48

< q49

< h49
hint: 


< a49

< q50

< h50
hint: 


< a50

< q51

< h51
hint: 


< a51

< q52

< h52
hint: 


< a52

< q53

< h53
hint: 


< a53

< q54

< h54
hint: 


< a54

< q55

< h55
hint: 


< a55

< q56

< h56
hint: 


< a56

< q57

< h57
hint: 


< a57

< q58

< h58
hint: 


< a58

< q59

< h59
hint: 


< a59

< q60

< h60
hint: 


< a60

< q61

< h61
hint: 


< a61

< q62

< h62
hint: 


< a62

< q63

< h63
hint: 


< a63

< q64

< h64
hint: 


< a64

< q65

< h65
hint: 


< a65

< q66

< h66
hint: 


< a66

< q67

< h67
hint: 


< a67

< q68

< h68
hint: 


< a68

< q69

< h69
hint: 


< a69

< q70

< h70
hint: 


< a70

< q71

< h71
hint: 


< a71

< q72

< h72
hint: 


< a72

< q73

< h73
hint: 


< a73

< q74

< h74
hint: 


< a74

< q75

< h75
hint: 


< a75

< q76

< h76
hint: 


< a76

< q77

< h77
hint: 


< a77

< q78

< h78
hint: 


< a78

< q79

< h79
hint: 


< a79

< q80

< h80
hint: 


< a80

< q81

< h81
hint: 


< a81

< q82

< h82
No hints provided...


< a82

< q83

< h83
No hints provided...


< a83

< q84

< h84
hint: 


< a84

< q85

< h85
hint: 


< a85

< q86

< h86
hint: 


< a86

< q87

< h87
hint: 


< a87

< q88

< h88
hint: 


< a88

< q89

< h89
hint: 


< a89

< q90

< h90
hint: 


< a90

< q91

< h91
hint: 


< a91

< q92

< h92
No hints provided...


< a92

< q93

< h93
hint: 


< a93

< q94

< h94
hint: 


< a94

< q95

< h95
hint: 


< a95

< q96

< h96
hint: 


< a96

< q97

< h97
hint: 


< a97

< q98

< h98
No hints provided...


< a98

< q99

< h99
hint: 


< a99

< q100

< h100
hint: 


< a100

< q101

< h101
hint: 


< a101

< q102

< h102
hint: 


< a102

< q103

< h103
hint: 


< a103

< q104

< h104
hint: 


< a104
